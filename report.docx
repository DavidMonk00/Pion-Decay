Measuring π Decays

Abstract
This report looks at the formulation and use of Python software to simulate pion decays within a detector. This involved an object orientated approach and was able to measure the branching ratio to within X% of chosen value. The project also highlighted a number of limitations of the Python programming language.

Introduction


Method
	The main concept of the project was to generate a single pion and simulate its decay and then iterate this algorithm for a given number of particles. As the pion had relativistic energies, simple mechanics could not be implemented and so a relativity module was written, which included a four-vector class and its derivatives for position and energy. Within this class, a Lorentz boost method was included.
	Classes for pions, muons and electrons were all derived from a single particle class, which contained methods and data common to all particles. These included the mass, γ and β of the particle, where β was a three dimensional vector. The methods common to all particles involved calculation  of the position that the particle left the tube and where it entered and left the detector. These methods were initially the main source of tardiness within the simulation as the positions were calculated by generating an array of positions of the particle with respect to time, before looping over this array until its position was outside of the tube. This linear loop was too slow, especially in an interpreted language such as Python. In order to rectify this, the algorithm was changed such that it worked by halving the interval in which the correct value would be found until the accuracy was within a sufficient tolerance. This improved the time for the algorithm to complete from O(len(array)) to ~O(log2(len(array))).
	For the classes of pions and muons, a method to simulate a decay was implemented, which involved calculation of the energy (see equation{} for pions) of the particle in the rest frame of the initial particle, before Lorentz boosting back to the lab frame. The position of the decay was found by calculation the lifetime in the lab frame, before using the simple mechanics of distance = speed * time, in vector form. Each particle also had a separate method for determining the total energy deposited in the detector, for a given distance travelled. This involved implementing the criteria for the detector shown in the introduction.
	With the basic framework of the simulation complete, focus turned to generating data and analysis. It quickly became apparent that, despite efforts being made to optimise the code, simulation of 10^7 particles would be a lengthy process. Python is not well suited to multithreading and thus other options to improve performance had to be considered. One improvement was running multiple python scripts simultaneously, making use of one CPU core each, however while improving performance, this was only done on laboratory computers, as the heat management was markedly better than laptops. In order to collate all of the data created over multiple runs on different machines, data storage had to be de-centralised. This involved setting up an FTP (file transfer protocol) server and implementing the ftplib library within Python. Once implemented, performance of data generation improved considerably, as machines could be left to run over long periods of time, without the concern of loss of data.
	The generality of the simulation framework allowed for a number of metrics to be calculated.

Analysis


Conclusion

Bibliography
