Measuring π Decays

Abstract
This report looks at the formulation and use of Python software to simulate pion decays within a detector. This involved an object orientated approach and was able to measure the branching ratio to within X% of chosen value. The project also highlighted a number of limitations of the Python programming language.

Introduction


Method
	The main concept of the project was to generate a single pion and simulate its decay and then iterate this algorithm for a given number of particles. As the pion had relativistic energies, simple mechanics could not be implemented and so a relativity module was written, which included a four-vector class and its derivatives for position and energy. Within this class, a Lorentz boost method was included.
	Classes for pions, muons and electrons were all derived from a single particle class, which contained methods and data common to all particles. These included the mass, γ and β of the particle, where β was a three dimensional vector. The methods common to all particles involved calculation  of the position that the particle left the tube and where it entered and left the detector. In order to maximise the efficiency of the code, these methods had to be optimised fully. As the velocity of the particle was generated as vector, whether or not the particle passed through the detector could be determined by calculating the 'times' at which the vector passed through the two of the six planes of the detector. If the particle passed through either of these two planes within the 30cm square of the face of the detector, then it will have deposited energy. If the particle passed through the front face, the the next greatest 'time' value will be when it left the detector. If the particle only passed through the rear face of the detector, then the previous 'time' that it passed through a plane would be when it entered the detector. It was assumed that the particle passed through at least one of the z-planes as a result of the high energy of the particles.
	For the classes of pions and muons, a method to simulate a decay was implemented, which involved calculation of the energy (see equation{} for pions) of the particle in the rest frame of the initial particle, before Lorentz boosting back to the lab frame. The position of the decay was found by calculation the lifetime in the lab frame, before using the simple mechanics of distance = speed * time, in vector form. Each particle also had a separate method for determining the total energy deposited in the detector, for a given distance travelled. This involved implementing the criteria for the detector shown in the introduction.
	With the basic framework of the simulation complete, focus turned to generating data and analysis. It quickly became apparent that, despite efforts being made to optimise the code, simulation of 10^7 particles would be a lengthy process. Python is not well suited to multithreading and thus other options to improve performance had to be considered. One improvement was running multiple python scripts simultaneously, making use of one CPU core each, however while improving performance, this was only done on laboratory computers, as the heat management was markedly better than on a laptop. In order to collate all of the data created over multiple runs on different machines, data storage had to be de-centralised. This involved setting up an FTP (file transfer protocol) server and implementing the ftplib library within Python. Once implemented, performance of data generation improved considerably, as machines could be left to run over long periods of time, without the concern of loss of data.
	The generality of the simulation framework allowed for a number of metrics to be calculated. Each metric was allocated a method within both the Sim class and Plot class. For metrics which required a high number of particles, such as the energy deposited within the detector and the transverse momentum, the data was written to disc (and uploaded to the FTP server in the case of energy deposited). This ensured that there could be no stack overflow within Python arrays and that data would not be lost if an error occurred. 

Analysis


Conclusion

Bibliography
